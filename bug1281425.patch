From fd08cc43299ced715e00083b4288dca16ad1b4ff Mon Sep 17 00:00:00 2001
From: Vadim Rutkovsky <vrutkovs@redhat.com>
Date: Fri, 16 Dec 2016 00:46:50 +0100
Subject: [PATCH] bug1281425.patch

---
 config/system-headers                |   1 +
 dom/ipc/ContentChild.cpp             |  40 +++-
 gfx/gl/GLContextProviderGLX.cpp      |   2 +
 gfx/thebes/gfxFcPlatformFontList.cpp |  14 +-
 gfx/thebes/gfxPlatformGtk.cpp        |  37 ++--
 gfx/thebes/gfxPlatformGtk.h          |  27 ++-
 toolkit/library/moz.build            |   3 +
 widget/gtk/WindowSurfaceProvider.cpp |  58 ++++--
 widget/gtk/WindowSurfaceProvider.h   |  24 ++-
 widget/gtk/WindowSurfaceWayland.cpp  | 353 +++++++++++++++++++++++++++++++++++
 widget/gtk/WindowSurfaceWayland.h    |  82 ++++++++
 widget/gtk/X11CompositorWidget.h     |   5 +
 widget/gtk/moz.build                 |   2 +
 widget/gtk/mozcontainer.c            | 183 +++++++++++++++++-
 widget/gtk/mozcontainer.h            |  22 ++-
 widget/gtk/mozgtk/mozgtk.c           |   8 +
 widget/gtk/nsNativeThemeGTK.cpp      |   6 +-
 widget/gtk/nsScreenGtk.cpp           |  10 +-
 widget/gtk/nsWindow.cpp              |  87 +++++++--
 widget/gtk/nsWindow.h                |   5 +-
 widget/gtk/os-compatibility.c        | 201 ++++++++++++++++++++
 widget/gtk/os-compatibility.h        |  54 ++++++
 widget/nsBaseWidget.cpp              |   3 +-
 widget/nsIWidget.h                   |   2 +
 24 files changed, 1150 insertions(+), 79 deletions(-)
 create mode 100644 widget/gtk/WindowSurfaceWayland.cpp
 create mode 100644 widget/gtk/WindowSurfaceWayland.h
 create mode 100644 widget/gtk/os-compatibility.c
 create mode 100644 widget/gtk/os-compatibility.h

diff --git a/config/system-headers b/config/system-headers
index 5852ff4..8ebc110 100644
--- a/config/system-headers
+++ b/config/system-headers
@@ -489,6 +489,7 @@ gdk/gdkkeysyms.h
 gdk/gdkprivate.h
 gdk/gdkx.h
 gdk/gdkdirectfb.h
+gdk/gdkwayland.h
 gdk-pixbuf/gdk-pixbuf.h
 Gestalt.h
 getopt.h
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index d7e0c4a..adae7c1 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -530,6 +530,44 @@ NS_INTERFACE_MAP_BEGIN(ContentChild)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentChild)
 NS_INTERFACE_MAP_END
 
+#ifdef MOZ_WIDGET_GTK
+// We need to keep in sync whith the same detection routine at nsAppRunner.cpp
+static char* detectDisplay(void)
+{
+  bool tryX11 = false;
+  bool tryWayland = false;
+  bool tryBroadway = false;
+
+  // Honor user backend selection
+  char *backend = PR_GetEnv("GDK_BACKEND");
+  if (!backend || strstr(backend, "*")) {
+    // Try all backends
+    tryX11 = true;
+    tryWayland = true;
+    tryBroadway = true;
+  } else if (backend) {
+    if (strstr(backend, "x11"))
+      tryX11 = true;
+    if (strstr(backend, "wayland"))
+      tryWayland = true;
+    if (strstr(backend, "broadway"))
+      tryBroadway = true;
+  }
+
+  char *display_name;
+  if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
+    return display_name;
+  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+    return display_name;
+  } else if (tryBroadway && (display_name = PR_GetEnv("BROADWAY_DISPLAY"))) {
+    return display_name;
+  }
+
+  PR_fprintf(PR_STDERR, "Error: GDK_BACKEND does not match available displays\n");
+  return nullptr;
+}
+#endif
+
 bool
 ContentChild::Init(MessageLoop* aIOLoop,
                    base::ProcessId aParentPid,
@@ -541,7 +579,7 @@ ContentChild::Init(MessageLoop* aIOLoop,
   // to use, and when starting under XWayland, it may choose to start with
   // the wayland backend instead of the x11 backend.
   // The DISPLAY environment variable is normally set by the parent process.
-  char* display_name = PR_GetEnv("DISPLAY");
+  char* display_name = detectDisplay();
   if (display_name) {
     int argc = 3;
     char option_name[] = "--display";
diff --git a/gfx/gl/GLContextProviderGLX.cpp b/gfx/gl/GLContextProviderGLX.cpp
index 9a1157f..09eb82a 100644
--- a/gfx/gl/GLContextProviderGLX.cpp
+++ b/gfx/gl/GLContextProviderGLX.cpp
@@ -67,6 +67,8 @@ HasExtension(const char* aExtensions, const char* aRequiredExtension)
 bool
 GLXLibrary::EnsureInitialized()
 {
+    return false;
+
     if (mInitialized) {
         return true;
     }
diff --git a/gfx/thebes/gfxFcPlatformFontList.cpp b/gfx/thebes/gfxFcPlatformFontList.cpp
index 6dbd8fa..96e29e7 100644
--- a/gfx/thebes/gfxFcPlatformFontList.cpp
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp
@@ -775,12 +775,14 @@ PreparePattern(FcPattern* aPattern, bool aIsPrinterFont)
 #endif
 
 #ifdef MOZ_X11
-        FcValue value;
-        int lcdfilter;
-        if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
-                == FcResultNoMatch &&
-            GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
-            FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+        if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+            FcValue value;
+            int lcdfilter;
+            if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
+                    == FcResultNoMatch &&
+                GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
+                FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+            }
         }
 #endif
     }
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index 9d7f512..20fbd3d 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -55,6 +55,10 @@
 
 #endif /* MOZ_X11 */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <fontconfig/fontconfig.h>
 
 #include "nsMathUtils.h"
@@ -105,14 +109,20 @@ gfxPlatformGtk::gfxPlatformGtk()
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
 
-#ifdef MOZ_X11
-    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
-      mCompositorDisplay = XOpenDisplay(nullptr);
-      MOZ_ASSERT(mCompositorDisplay, "Failed to create compositor display!");
-    } else {
-      mCompositorDisplay = nullptr;
+#if defined(MOZ_X11)
+    GdkDisplay *gdkDisplay = gdk_display_get_default();
+    mIsX11Display = GDK_IS_X11_DISPLAY(gdkDisplay);
+    if (mIsX11Display) {
+      mXCompositorDisplay = XOpenDisplay(nullptr);
+      MOZ_ASSERT(mXCompositorDisplay, "Failed to create compositor display!");
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+      mWaylandCompositorDisplay = wl_display_connect(nullptr);
+      MOZ_ASSERT(mWaylandCompositorDisplay, "Failed to create compositor display!");
     }
-#endif // MOZ_X11
+#endif
+#endif // defined(MOZ_X11)
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
@@ -123,11 +133,16 @@ gfxPlatformGtk::~gfxPlatformGtk()
         gfxPangoFontGroup::Shutdown();
     }
 
-#ifdef MOZ_X11
-    if (mCompositorDisplay) {
-      XCloseDisplay(mCompositorDisplay);
+#if defined(MOZ_X11)
+    if (mIsX11Display) {
+       XCloseDisplay(mXCompositorDisplay);
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+       wl_display_disconnect(mWaylandCompositorDisplay);
     }
-#endif // MOZ_X11
+#endif
+#endif
 }
 
 void
diff --git a/gfx/thebes/gfxPlatformGtk.h b/gfx/thebes/gfxPlatformGtk.h
index 982390d..2e3c39b 100644
--- a/gfx/thebes/gfxPlatformGtk.h
+++ b/gfx/thebes/gfxPlatformGtk.h
@@ -21,6 +21,12 @@ extern "C" {
 struct _XDisplay;
 typedef struct _XDisplay Display;
 #endif // MOZ_X11
+#ifndef GDK_WINDOWING_WAYLAND
+#define GDK_WINDOWING_WAYLAND 1
+#endif
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_display;
+#endif
 
 class gfxFontconfigUtils;
 
@@ -104,7 +110,7 @@ public:
     static int32_t GetDPI();
     static double  GetDPIScale();
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     virtual void GetAzureBackendInfo(mozilla::widget::InfoObject &aObj) override {
       gfxPlatform::GetAzureBackendInfo(aObj);
       aObj.DefineProperty("CairoUseXRender", mozilla::gfx::gfxVars::UseXRender());
@@ -146,9 +152,17 @@ public:
 #endif
 
 #ifdef MOZ_X11
-    Display* GetCompositorDisplay() {
-      return mCompositorDisplay;
+    bool     IsXDisplay() {
+      return mIsX11Display;
+    }
+    Display* GetXCompositorDisplay() {
+      return mXCompositorDisplay;
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* GetWaylandCompositorDisplay() {
+      return mWaylandCompositorDisplay;
+    }
+#endif
 #endif // MOZ_X11
 
 protected:
@@ -159,9 +173,12 @@ protected:
 private:
     virtual void GetPlatformCMSOutputProfile(void *&mem,
                                              size_t &size) override;
-
 #ifdef MOZ_X11
-    Display* mCompositorDisplay;
+    bool        mIsX11Display;
+    Display*    mXCompositorDisplay;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* mWaylandCompositorDisplay;
+#endif
 #endif
 
     // xxx - this will be removed once the new fontconfig platform font list
diff --git a/toolkit/library/moz.build b/toolkit/library/moz.build
index d73fbdf..3f8d2a1 100644
--- a/toolkit/library/moz.build
+++ b/toolkit/library/moz.build
@@ -310,6 +310,9 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     OS_LIBS += [
         'gthread-2.0',
     ]
+    OS_LIBS += [
+        'wayland-client',
+    ]
 
 if CONFIG['MOZ_ENABLE_STARTUP_NOTIFICATION']:
     OS_LIBS += CONFIG['MOZ_STARTUP_NOTIFICATION_LIBS']
diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index 526fe6a..9a66619 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -11,6 +11,7 @@
 #include "WindowSurfaceX11Image.h"
 #include "WindowSurfaceX11SHM.h"
 #include "WindowSurfaceXRender.h"
+#include "WindowSurfaceWayland.h"
 
 namespace mozilla {
 namespace widget {
@@ -19,11 +20,14 @@ using namespace mozilla::gfx;
 using namespace mozilla::layers;
 
 WindowSurfaceProvider::WindowSurfaceProvider()
-    : mXDisplay(nullptr)
+    : mIsX11Display(false)
+    , mXDisplay(nullptr)
     , mXWindow(0)
     , mXVisual(nullptr)
     , mXDepth(0)
+    , mWaylandDisplay(nullptr)
     , mWindowSurface(nullptr)
+    , mWaylandSurface(nullptr)
 {
 }
 
@@ -43,7 +47,21 @@ void WindowSurfaceProvider::Initialize(
   mXWindow = aWindow;
   mXVisual = aVisual;
   mXDepth = aDepth;
+  mIsX11Display = true;
 }
+
+void WindowSurfaceProvider::Initialize(
+      wl_display *aWaylandDisplay,
+      wl_surface *aWaylandSurface)
+{
+  // We should not be initialized
+  MOZ_ASSERT(!mWaylandSurface);
+
+  mWaylandDisplay = aWaylandDisplay;
+  mWaylandSurface = aWaylandSurface;
+  mIsX11Display = false;
+}
+
 void WindowSurfaceProvider::CleanupResources()
 {
   mWindowSurface = nullptr;
@@ -52,30 +70,36 @@ void WindowSurfaceProvider::CleanupResources()
 UniquePtr<WindowSurface>
 WindowSurfaceProvider::CreateWindowSurface()
 {
-  // We should be initialized
-  MOZ_ASSERT(mXDisplay);
+  if (mIsX11Display) {
+    // We should be initialized
+    MOZ_ASSERT(mXDisplay);
 
-  // Blit to the window with the following priority:
-  // 1. XRender (iff XRender is enabled && we are in-process)
-  // 2. MIT-SHM
-  // 3. XPutImage
+    // Blit to the window with the following priority:
+    // 1. XRender (iff XRender is enabled && we are in-process)
+    // 2. MIT-SHM
+    // 3. XPutImage
 
 #ifdef MOZ_WIDGET_GTK
-  if (gfxVars::UseXRender()) {
-    LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
-    return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (gfxVars::UseXRender()) {
+      LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
+      return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_WIDGET_GTK
 
 #ifdef MOZ_HAVE_SHMIMAGE
-  if (nsShmImage::UseShm()) {
-    LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
-    return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (nsShmImage::UseShm()) {
+      LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
+      return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_HAVE_SHMIMAGE
 
-  LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
-  return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
+    return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  } else {
+    MOZ_ASSERT(mWaylandDisplay);
+    LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
+    return MakeUnique<WindowSurfaceWayland>(mWaylandDisplay, mWaylandSurface);
+  }
 }
 
 already_AddRefed<gfx::DrawTarget>
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index 73b2303..92713c2 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -12,6 +12,10 @@
 #include "mozilla/gfx/2D.h"
 #include "Units.h"
 
+#include <gdk/gdk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #include <X11/Xlib.h> // for Window, Display, Visual, etc.
 
 namespace mozilla {
@@ -39,6 +43,11 @@ public:
       Visual* aVisual,
       int aDepth);
 
+#ifdef GDK_WINDOWING_WAYLAND
+   void Initialize(wl_display *aWaylandDisplay,
+                   wl_surface *aWaylandSurface);
+#endif
+
   /**
    * Releases any surfaces created by this provider.
    * This is used by X11CompositorWidget to get rid
@@ -55,11 +64,16 @@ public:
 private:
   UniquePtr<WindowSurface> CreateWindowSurface();
 
-  Display*  mXDisplay;
-  Window    mXWindow;
-  Visual*   mXVisual;
-  int       mXDepth;
-
+  // Can we access X?
+  bool        mIsX11Display;
+  Display*    mXDisplay;
+  Window      mXWindow;
+  Visual*     mXVisual;
+  int         mXDepth;
+#ifdef GDK_WINDOWING_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif
   UniquePtr<WindowSurface> mWindowSurface;
 };
 
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
new file mode 100644
index 0000000..7836d32
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -0,0 +1,353 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * Derived from Weston project,
+ * https://github.com/wayland-project/weston/blob/master/clients/simple-shm.c
+ */
+/*
+- make it work single thread, no e10s
+- simple multi-thread app
+- abort() on exhausted buffer pool
+
+TODO:
+moz-container -> display check
+X11CompositorWidget - update
+nsWindow::GetCompositorWidgetInitData
+GDK_WINDOWING_X11 - remove
+#ifdef GDK_WINDOWING_WAYLAND + display test
+- ensure we always draw to container
+- surface cleaning/realocation
+- can we redraw on allocate?
+- create subsurface on show
+- share fd/pool with more buffers?
+- resize (pool size) optimization
+- pool of available buffers?
+*/
+#include <assert.h>
+#include "WindowSurfaceWayland.h"
+
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/Tools.h"
+#include "gfxPlatform.h"
+#include "os-compatibility.h"
+
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+#include <sys/mman.h>
+#include <fcntl.h>
+
+namespace mozilla {
+namespace widget {
+
+bool                WindowSurfaceWayland::mIsAvailable;
+bool                WindowSurfaceWayland::mInitialized;
+gfx::SurfaceFormat  WindowSurfaceWayland::mFormat = gfx::SurfaceFormat::UNKNOWN;
+wl_shm*             WindowSurfaceWayland::mShm;
+
+bool SurfaceBuffer::CreateShmPool(int aSize)
+{
+  mAllocatedSize = aSize;
+
+  mShmPoolFd = os_create_anonymous_file(mAllocatedSize);
+  if (mShmPoolFd < 0)
+    return false;
+
+  mBufferData = mmap(nullptr, mAllocatedSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED) {
+    close(mShmPoolFd);
+    mShmPoolFd = 0;
+    return false;
+  }
+
+  mShmPool = wl_shm_create_pool(WindowSurfaceWayland::GetShm(),
+                                mShmPoolFd, mAllocatedSize);
+  return true;
+}
+
+bool SurfaceBuffer::ResizeShmPool(int aSize)
+{
+  // We do size increase only
+  if (aSize <= mAllocatedSize)
+    return true;
+
+  if (ftruncate(mShmPoolFd, aSize) < 0)
+    return false;
+
+#ifdef HAVE_POSIX_FALLOCATE
+  errno = posix_fallocate(mShmPoolFd, 0, aSize);
+  if (errno != 0)
+    return false;
+#endif
+
+  wl_shm_pool_resize(mShmPool, aSize);
+
+  munmap(mBufferData, mAllocatedSize);
+
+  mBufferData = mmap(nullptr, aSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED)
+    return false;
+
+  mAllocatedSize = aSize;
+  return true;
+}
+
+void SurfaceBuffer::ReleaseShmPool()
+{
+  munmap(mBufferData, mAllocatedSize);
+  wl_shm_pool_destroy(mShmPool);
+  close(mShmPoolFd);
+
+  mBufferData = nullptr;
+  mAllocatedSize = 0;
+}
+
+static void
+buffer_release(void *data, wl_buffer *buffer)
+{
+  auto surface = reinterpret_cast<SurfaceBuffer*>(data);
+  surface->Detach();
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+  buffer_release
+};
+
+void SurfaceBuffer::CreateBuffer(int aWidth, int aHeight)
+{
+  mBuffer = wl_shm_pool_create_buffer(mShmPool, 0,
+                              			  aWidth, aHeight, aWidth*BUFFER_BPP,
+                              			  WL_SHM_FORMAT_ARGB8888);
+  wl_buffer_add_listener(mBuffer, &buffer_listener, this);
+
+  mWidth = aWidth;
+  mHeight = aHeight;
+}
+
+void SurfaceBuffer::ReleaseBuffer()
+{
+  wl_buffer_destroy(mBuffer);
+   mWidth = mHeight = 0;
+}
+
+SurfaceBuffer::SurfaceBuffer(int aWidth, int aHeight)
+ : mShmPool(nullptr)
+  ,mShmPoolFd(0)
+  ,mAllocatedSize(0)
+  ,mBuffer(nullptr)
+  ,mBufferData(nullptr)
+  ,mWidth(0)
+  ,mHeight(0)
+  ,mFormat(gfx::SurfaceFormat::B8G8R8A8)
+  ,mAttached(false)
+{
+  if(CreateShmPool(aWidth*aHeight*BUFFER_BPP)) {
+    CreateBuffer(aWidth, aHeight);
+  } else
+    assert(0);
+}
+
+SurfaceBuffer::~SurfaceBuffer()
+{
+  ReleaseBuffer();
+  ReleaseShmPool();
+}
+
+bool SurfaceBuffer::Resize(int aWidth, int aHeight)
+{
+  if (aWidth == mWidth && aHeight == mHeight)
+    return true;
+
+  ReleaseBuffer();
+
+  int newSize = aWidth*aHeight*BUFFER_BPP;
+  if (newSize > mAllocatedSize)
+    ResizeShmPool(newSize);
+
+  CreateBuffer(aWidth, aHeight);
+  return (mBuffer != nullptr);
+}
+
+already_AddRefed<gfx::DrawTarget>
+SurfaceBuffer::Lock()
+{
+  unsigned char* data = static_cast<unsigned char*>(mBufferData);
+  return gfxPlatform::CreateDrawTargetForData(data,
+                                              gfx::IntSize(mWidth, mHeight),
+                                              mWidth*BUFFER_BPP,
+                                              mFormat);
+}
+
+void
+SurfaceBuffer::Attach(wl_surface* aSurface,
+                      const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+
+  wl_surface_damage(aSurface, bounds.x, bounds.y, size.width, size.height);
+  wl_surface_attach(aSurface, mBuffer, 0, 0);
+  wl_surface_commit(aSurface);
+
+  mAttached = true;
+}
+
+void
+SurfaceBuffer::Detach()
+{
+  mAttached = false;
+}
+
+bool SurfaceBuffer::Sync(class SurfaceBuffer* aSourceBuffer)
+{
+  if (mWidth != aSourceBuffer->mWidth || mHeight != aSourceBuffer->mHeight)
+    return false;
+
+  int bufferSize = mWidth*mHeight*BUFFER_BPP;
+  memcpy(mBufferData, aSourceBuffer->mBufferData, bufferSize);
+  return true;
+}
+
+void
+WindowSurfaceWayland::SetWaylandPixelFormat(uint32_t format)
+{
+  switch (format) {
+    case WL_SHM_FORMAT_ARGB8888:
+      mFormat = gfx::SurfaceFormat::B8G8R8A8;
+      break;
+    case WL_SHM_FORMAT_XRGB8888:
+      // TODO - We can use non-alpha formats when we need that
+    default:
+      break;
+  }
+}
+
+static void
+shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+{
+  auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+  interface->SetWaylandPixelFormat(format);
+ }
+
+struct wl_shm_listener shm_listener = {
+	shm_format
+};
+
+static void
+global_registry_handler(void *data, wl_registry *registry, uint32_t id,
+	                      const char *interface, uint32_t version)
+{
+  if (strcmp(interface, "wl_shm") == 0) {
+    auto shm = static_cast<wl_shm*>(
+        wl_registry_bind(registry, id, &wl_shm_interface, 1));
+    wl_shm_add_listener(shm, &shm_listener, NULL);
+    auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+    interface->SetShm(shm);
+  }
+}
+
+static void
+global_registry_remover(void *data, wl_registry *registry, uint32_t id)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  global_registry_handler,
+  global_registry_remover
+};
+
+void
+WindowSurfaceWayland::Init()
+{
+  // Try to initialize only once
+  if (mInitialized)
+    return;
+  mInitialized = true;
+
+  // wl_shm and wl_subcompositor are not provided by Gtk so we need
+  // to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);  
+  wl_registry_add_listener(registry,
+                           &registry_listener, nullptr);
+  wl_display_dispatch(mDisplay);
+  wl_display_roundtrip(mDisplay);
+
+  // We should have a valid pixel format now
+  mIsAvailable = (mFormat != gfx::SurfaceFormat::UNKNOWN);
+  NS_ASSERTION(mIsAvailable, "We don't have any pixel format!");
+}
+
+WindowSurfaceWayland::WindowSurfaceWayland(wl_display *aDisplay,
+                                           wl_surface *aSurface)
+  : mDisplay(aDisplay)
+  , mSurface(aSurface)
+  , mBuffers{nullptr, nullptr}
+  , mFrontBuffer(0)
+  , mLastBuffer(0)
+{
+  NS_ASSERTION(mSurface != nullptr,
+               "Missing Wayland surfaces to draw to!");
+  Init();
+}
+
+WindowSurfaceWayland::~WindowSurfaceWayland()
+{
+}
+
+SurfaceBuffer*
+WindowSurfaceWayland::SetBufferToDraw(int aWidth, int aHeight)
+{
+  if (!mBuffers[0] || !mBuffers[0]->IsAttached()) {
+    mFrontBuffer = 0;
+  } else if (!mBuffers[1] || !mBuffers[1]->IsAttached()) {
+    mFrontBuffer = 1;
+  } else {
+    // No buffer left?
+    assert(0);
+    return nullptr;
+  }
+
+  if (mBuffers[mFrontBuffer] != nullptr) {
+    mBuffers[mFrontBuffer]->Resize(aWidth, aHeight);
+  } else {
+    mBuffers[mFrontBuffer] = new SurfaceBuffer(aWidth, aHeight);    
+  }
+  
+  // Sync last and front buffer
+  if (mFrontBuffer != mLastBuffer) {  
+    mBuffers[mFrontBuffer]->Sync(mBuffers[mLastBuffer]);
+    mLastBuffer = mFrontBuffer;
+  }
+
+  return mBuffers[mFrontBuffer]->IsValid() ? mBuffers[mFrontBuffer] : nullptr;
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize size(bounds.XMost(), bounds.YMost());
+
+  SurfaceBuffer* buffer = SetBufferToDraw(size.width, size.height);
+  assert(buffer);
+  if (!buffer)
+    return nullptr;
+
+  return buffer->Lock();
+}
+
+void
+WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  MOZ_ASSERT(mBuffers[mFrontBuffer], "Attempted to commit invalid surface!");  
+  mBuffers[mFrontBuffer]->Attach(mSurface, aInvalidRegion);
+}
+
+}  // namespace widget
+}  // namespace mozilla
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
new file mode 100644
index 0000000..fd720dd
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -0,0 +1,82 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+#define _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+
+namespace mozilla {
+namespace widget {
+
+// We support only 32bpp formats
+#define BUFFER_BPP 4
+
+// Holds actual graphics data for wl_surface
+class SurfaceBuffer {
+public:
+  SurfaceBuffer(int aWidth, int aHeight);
+  ~SurfaceBuffer();
+
+  void Attach(wl_surface* aSurface,
+              const LayoutDeviceIntRegion& aInvalidRegion);
+  void Detach();
+  bool IsAttached() { return mAttached; }
+  bool IsValid()    { return mBuffer && mBufferData; }
+
+  bool Resize(int aWidth, int aHeight);
+  bool Sync(class SurfaceBuffer* aSourceBuffer);
+  
+  already_AddRefed<gfx::DrawTarget> Lock();
+
+private:
+  bool CreateShmPool(int aSize);
+  bool ResizeShmPool(int aSize);
+  void ReleaseShmPool(void);
+
+  void CreateBuffer(int aWidth, int aHeight);
+  void ReleaseBuffer();
+
+  wl_shm_pool*       mShmPool;
+  int                mShmPoolFd;
+  int                mAllocatedSize;
+  wl_buffer*         mBuffer;
+  void*              mBufferData;
+  int                mWidth;
+  int                mHeight;
+  gfx::SurfaceFormat mFormat;
+  bool               mAttached;
+};
+
+class WindowSurfaceWayland : public WindowSurface {
+public:
+  WindowSurfaceWayland(wl_display *aDisplay, wl_surface *aSurface);
+  ~WindowSurfaceWayland();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
+  void Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
+
+  static void SetShm(wl_shm* aShm) { mShm = aShm; };
+  static wl_shm* GetShm() { return(mShm); };
+  static void SetWaylandPixelFormat(uint32_t format);
+
+private:
+  SurfaceBuffer* SetBufferToDraw(int aWidth, int aHeight);
+  void           Init();
+
+  static bool               mIsAvailable;
+  static bool               mInitialized;
+  static gfx::SurfaceFormat mFormat;
+  static wl_shm*            mShm;
+  wl_display*               mDisplay;  
+  wl_surface*               mSurface;
+  SurfaceBuffer*            mBuffers[2];
+  int                       mFrontBuffer;
+  int                       mLastBuffer;
+};
+
+}  // namespace widget
+}  // namespace mozilla
+
+#endif // _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
diff --git a/widget/gtk/X11CompositorWidget.h b/widget/gtk/X11CompositorWidget.h
index c0e0ede..c9a9a65 100644
--- a/widget/gtk/X11CompositorWidget.h
+++ b/widget/gtk/X11CompositorWidget.h
@@ -58,8 +58,13 @@ protected:
 private:
   LayoutDeviceIntSize mClientSize;
 
+  bool     mIsX11Display;
   Display* mXDisplay;
   Window   mXWindow;
+#ifdef GDK_WINDOWING_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif  
   WindowSurfaceProvider mProvider;
 };
 
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index baccb6c..714e6a0 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -34,6 +34,7 @@ UNIFIED_SOURCES += [
     'nsSound.cpp',
     'nsToolkit.cpp',
     'nsWidgetFactory.cpp',
+    'os-compatibility.c',
     'WakeLockListener.cpp',
     'WidgetTraceEvent.cpp',
     'WidgetUtilsGtk.cpp',
@@ -74,6 +75,7 @@ if CONFIG['MOZ_X11']:
         'nsClipboard.cpp',
         'nsDragService.cpp',
         'WindowSurfaceProvider.cpp',
+        'WindowSurfaceWayland.cpp',
         'WindowSurfaceX11.cpp',
         'WindowSurfaceX11Image.cpp',
         'WindowSurfaceXRender.cpp',
diff --git a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.c
index 9b596e4..3d2f39c 100644
--- a/widget/gtk/mozcontainer.c
+++ b/widget/gtk/mozcontainer.c
@@ -7,12 +7,17 @@
 
 #include "mozcontainer.h"
 #include <gtk/gtk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <stdio.h>
+#include <string.h>
 
 #ifdef ACCESSIBILITY
 #include <atk/atk.h>
 #include "maiRedundantObjectFactory.h"
-#endif 
+#endif
 
 /* init methods */
 static void moz_container_class_init          (MozContainerClass *klass);
@@ -22,6 +27,9 @@ static void moz_container_init                (MozContainer      *container);
 static void moz_container_map                 (GtkWidget         *widget);
 static void moz_container_unmap               (GtkWidget         *widget);
 static void moz_container_realize             (GtkWidget         *widget);
+#if defined(GDK_WINDOWING_WAYLAND)
+static void moz_container_unrealize           (GtkWidget         *widget);
+#endif
 static void moz_container_size_allocate       (GtkWidget         *widget,
                                                GtkAllocation     *allocation);
 
@@ -143,6 +151,74 @@ moz_container_move (MozContainer *container, GtkWidget *child_widget,
 
 /* static methods */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+/* We have to recreate our wl_surfaces when GdkWindow is shown,
+ * otherwise Gdk resources may not finished 
+ * and gdk_wayland_window_get_wl_surface() fails.
+ */
+gboolean
+moz_container_map_wl_surface(MozContainer *container)
+{
+    GdkDisplay *display;
+    struct wl_compositor *compositor;
+    struct wl_surface *gtk_surface;
+    struct wl_region *region;
+    GdkWindow *window;
+    gint x, y;
+    
+    if (container->subsurface)
+      return TRUE;
+
+    window = gtk_widget_get_window(GTK_WIDGET(container));
+    gtk_surface = gdk_wayland_window_get_wl_surface(window);
+    if (!gtk_surface) {
+      // We requested the underlying wl_surface too early. 
+      return FALSE;
+    }
+    
+    container->subsurface =
+      wl_subcompositor_get_subsurface (container->subcompositor,
+                                       container->surface,
+                                       gtk_surface);
+    gdk_window_get_position(window, &x, &y);
+    wl_subsurface_set_position(container->subsurface, x, y);
+    wl_subsurface_set_desync(container->subsurface);
+
+    // Don't accept input on subsurface
+    display = gtk_widget_get_display(GTK_WIDGET (container));
+    compositor = gdk_wayland_display_get_wl_compositor(display);
+    region = wl_compositor_create_region(compositor);
+    wl_surface_set_input_region(container->surface, region);
+    wl_region_destroy(region);
+    return TRUE;
+}
+
+static void
+moz_container_unmap_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
+}
+
+static void
+moz_container_create_surface(MozContainer *container)
+{
+    if (container->subcompositor && !container->surface) {
+        GdkDisplay *display;
+        struct wl_compositor *compositor;
+
+        display = gtk_widget_get_display(GTK_WIDGET (container));
+        compositor = gdk_wayland_display_get_wl_compositor(display);
+        container->surface = wl_compositor_create_surface(compositor);
+    }
+}
+
+static void
+moz_container_delete_surface(MozContainer *container)
+{  
+    g_clear_pointer(&container->surface, wl_surface_destroy);
+}
+#endif
+
 void
 moz_container_class_init (MozContainerClass *klass)
 {
@@ -154,6 +230,9 @@ moz_container_class_init (MozContainerClass *klass)
     widget_class->map = moz_container_map;
     widget_class->unmap = moz_container_unmap;
     widget_class->realize = moz_container_realize;
+#if defined(GDK_WINDOWING_WAYLAND)
+    widget_class->unrealize = moz_container_unrealize;    
+#endif
     widget_class->size_allocate = moz_container_size_allocate;
 
     container_class->remove = moz_container_remove;
@@ -161,12 +240,58 @@ moz_container_class_init (MozContainerClass *klass)
     container_class->add = moz_container_add;
 }
 
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+registry_handle_global (void *data,
+                        struct wl_registry *registry,
+                        uint32_t name,
+                        const char *interface,
+                        uint32_t version)
+{
+    MozContainer *container = data;
+    if(strcmp(interface, "wl_subcompositor") == 0) {
+        container->subcompositor = wl_registry_bind(registry,
+                                                    name,
+                                                    &wl_subcompositor_interface,
+                                                    1);
+    }
+}
+
+static void
+registry_handle_global_remove (void *data,
+                               struct wl_registry *registry,
+                               uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+#endif
+
 void
 moz_container_init (MozContainer *container)
 {
     gtk_widget_set_can_focus(GTK_WIDGET(container), TRUE);
     gtk_container_set_resize_mode(GTK_CONTAINER(container), GTK_RESIZE_IMMEDIATE);
     gtk_widget_set_redraw_on_allocate(GTK_WIDGET(container), FALSE);
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    {
+      GdkDisplay *gdk_display = gtk_widget_get_display(GTK_WIDGET(container));
+      if (GDK_IS_WAYLAND_DISPLAY (gdk_display)) {
+          struct wl_display *display;
+          struct wl_registry *registry;
+
+          display = gdk_wayland_display_get_wl_display(gdk_display);
+          registry = wl_display_get_registry(display);
+          wl_registry_add_listener(registry, &registry_listener, container);
+
+          wl_display_roundtrip(display);
+        }
+    }
+#endif
 }
 
 void
@@ -184,7 +309,7 @@ moz_container_map (GtkWidget *widget)
     tmp_list = container->children;
     while (tmp_list) {
         tmp_child = ((MozContainerChild *)tmp_list->data)->widget;
-    
+
         if (gtk_widget_get_visible(tmp_child)) {
             if (!gtk_widget_get_mapped(tmp_child))
                 gtk_widget_map(tmp_child);
@@ -207,6 +332,13 @@ moz_container_unmap (GtkWidget *widget)
     if (gtk_widget_get_has_window (widget)) {
         gdk_window_hide (gtk_widget_get_window(widget));
     }
+#if defined(GDK_WINDOWING_WAYLAND)
+  /* Gdk/Wayland deletes underlying GdkWindow wl_surface on unmap event.
+   * Delete the wl_subsurface interface which
+   * keeps wl_surface object and it's available to reuse.
+   */
+    moz_container_unmap_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
 void
@@ -221,6 +353,7 @@ moz_container_realize (GtkWidget *widget)
         GdkWindowAttr attributes;
         gint attributes_mask = GDK_WA_VISUAL | GDK_WA_X | GDK_WA_Y;
         GtkAllocation allocation;
+        GtkWidget* parent_widget;
 
         gtk_widget_get_allocation (widget, &allocation);
         attributes.event_mask = gtk_widget_get_events (widget);
@@ -231,6 +364,16 @@ moz_container_realize (GtkWidget *widget)
         attributes.wclass = GDK_INPUT_OUTPUT;
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.window_type = GDK_WINDOW_CHILD;
+#if defined(GDK_WINDOWING_WAYLAND)        
+        /* TODO: We may optimize the code to use GDK_WINDOW_SUBSURFACE
+         * for all windows
+         */
+        parent_widget = gtk_widget_get_parent(widget);
+        if (parent_widget &&
+            gtk_window_get_window_type(GTK_WINDOW(parent_widget)) == GTK_WINDOW_POPUP) {
+            attributes.window_type = GDK_WINDOW_SUBSURFACE;
+        }
+#endif
 
 #if (MOZ_WIDGET_GTK == 2)
         attributes.colormap = gtk_widget_get_colormap (widget);
@@ -255,7 +398,20 @@ moz_container_realize (GtkWidget *widget)
 #if (MOZ_WIDGET_GTK == 2)
     widget->style = gtk_style_attach (widget->style, widget->window);
 #endif
+#if defined(GDK_WINDOWING_WAYLAND)
+    moz_container_create_surface(MOZ_CONTAINER(widget));    
+#endif
+}
+
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+moz_container_unrealize (GtkWidget *widget)
+{
+  MozContainer* container = MOZ_CONTAINER(widget);
+  moz_container_unmap_surface(container);
+  moz_container_delete_surface(container);
 }
+#endif
 
 void
 moz_container_size_allocate (GtkWidget     *widget,
@@ -267,7 +423,7 @@ moz_container_size_allocate (GtkWidget     *widget,
 
     g_return_if_fail (IS_MOZ_CONTAINER (widget));
 
-    /*  printf("moz_container_size_allocate %p %d %d %d %d\n",
+      /* printf("moz_container_size_allocate %p %d %d %d %d\n",
         (void *)widget,
         allocation->x,
         allocation->y,
@@ -306,6 +462,14 @@ moz_container_size_allocate (GtkWidget     *widget,
                                allocation->width,
                                allocation->height);
     }
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    if (container->subsurface) {        
+        gint x, y;
+        gdk_window_get_position(gtk_widget_get_window(widget), &x, &y);
+        wl_subsurface_set_position(container->subsurface, x, y);
+      }
+#endif
 }
 
 void
@@ -363,7 +527,7 @@ moz_container_forall (GtkContainer *container, gboolean include_internals,
 {
     MozContainer *moz_container;
     GList *tmp_list;
-  
+
     g_return_if_fail (IS_MOZ_CONTAINER(container));
     g_return_if_fail (callback != NULL);
 
@@ -399,7 +563,7 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     tmp_list = container->children;
     while (tmp_list) {
         MozContainerChild *child;
-    
+
         child = tmp_list->data;
         tmp_list = tmp_list->next;
 
@@ -410,9 +574,16 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     return NULL;
 }
 
-static void 
+static void
 moz_container_add(GtkContainer *container, GtkWidget *widget)
 {
     moz_container_put(MOZ_CONTAINER(container), widget, 0, 0);
 }
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface*
+moz_container_get_wl_surface(MozContainer *container)
+{
+    return container->surface;
+}
+#endif
diff --git a/widget/gtk/mozcontainer.h b/widget/gtk/mozcontainer.h
index 23e17f7..55f87b9 100644
--- a/widget/gtk/mozcontainer.h
+++ b/widget/gtk/mozcontainer.h
@@ -44,7 +44,7 @@ extern "C" {
  * gtk_widget_set_parent_window should be called on the child GtkWidget before
  * it is realized.
  */
- 
+
 #define MOZ_CONTAINER_TYPE            (moz_container_get_type())
 #define MOZ_CONTAINER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MOZ_CONTAINER_TYPE, MozContainer))
 #define MOZ_CONTAINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), MOZ_CONTAINER_TYPE, MozContainerClass))
@@ -55,10 +55,25 @@ extern "C" {
 typedef struct _MozContainer      MozContainer;
 typedef struct _MozContainerClass MozContainerClass;
 
+/* Workaround for bug at wayland-util.h,
+ * present in wayland < 1.12
+ */
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_subcompositor;
+struct wl_surface;
+struct wl_subsurface;
+#endif
+
 struct _MozContainer
 {
     GtkContainer   container;
     GList         *children;
+
+#ifdef GDK_WINDOWING_WAYLAND
+    struct wl_subcompositor *subcompositor;
+    struct wl_surface       *surface;
+    struct wl_subsurface    *subsurface;
+#endif
 };
 
 struct _MozContainerClass
@@ -79,6 +94,11 @@ void       moz_container_move          (MozContainer *container,
                                         gint          width,
                                         gint          height);
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface * moz_container_get_wl_surface (MozContainer *container);
+gboolean            moz_container_map_wl_surface (MozContainer *container);
+#endif
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
index 8b62943..259d810 100644
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -514,11 +514,19 @@ STUB(gdk_device_manager_get_client_pointer)
 STUB(gdk_disable_multidevice)
 STUB(gdk_device_manager_list_devices)
 STUB(gdk_display_get_device_manager)
+STUB(gdk_display_get_default_seat)
 STUB(gdk_error_trap_pop_ignored)
 STUB(gdk_event_get_source_device)
+STUB(gdk_seat_grab)
+STUB(gdk_seat_ungrab)
 STUB(gdk_window_get_type)
 STUB(gdk_x11_window_get_xid)
 STUB(gdk_x11_display_get_type)
+STUB(gdk_wayland_window_get_wl_surface)
+STUB(gdk_wayland_window_set_use_custom_surface)
+STUB(gdk_wayland_display_get_wl_display)
+STUB(gdk_wayland_display_get_wl_compositor)
+STUB(gdk_wayland_display_get_type)
 STUB(gtk_box_new)
 STUB(gtk_cairo_should_draw_window)
 STUB(gtk_cairo_transform_to_window)
diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
index 85ee364..33fce5d 100644
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -1220,7 +1220,11 @@ nsNativeThemeGTK::DrawWidgetBackground(nsRenderingContext* aContext,
 #endif
 
   if (!safeState) {
-    gdk_flush();
+    // gdk_flush() call from expose event crashes Gtk+ on Wayland
+    // (Gnome BZ #773307)
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      gdk_flush();
+    }
     gLastGdkError = gdk_error_trap_pop ();
 
     if (gLastGdkError) {
diff --git a/widget/gtk/nsScreenGtk.cpp b/widget/gtk/nsScreenGtk.cpp
index 61e6605..28e7f23 100644
--- a/widget/gtk/nsScreenGtk.cpp
+++ b/widget/gtk/nsScreenGtk.cpp
@@ -50,7 +50,7 @@ nsScreenGtk :: GetRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth, int
   *outHeight = mRect.height;
 
   return NS_OK;
-  
+
 } // GetRect
 
 
@@ -63,7 +63,7 @@ nsScreenGtk :: GetAvailRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth
   *outHeight = mAvailRect.height;
 
   return NS_OK;
-  
+
 } // GetAvailRect
 
 gint
@@ -93,7 +93,7 @@ nsScreenGtk :: GetDPIScale()
   return dpiScale;
 }
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 {
   GdkVisual * visual = gdk_screen_get_system_visual(gdk_screen_get_default());
@@ -103,7 +103,7 @@ nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 
 } // GetPixelDepth
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetColorDepth(int32_t *aColorDepth)
 {
   return GetPixelDepth ( aColorDepth );
@@ -130,6 +130,8 @@ nsScreenGtk :: Init (GdkWindow *aRootWindow)
   // versions of GDK predating the GdkScreen object.  See bug 256646.
   mAvailRect = mRect = nsIntRect(0, 0, width, height);
 
+  return;
+
 #ifdef MOZ_X11
   // We need to account for the taskbar, etc in the available rect.
   // See http://freedesktop.org/Standards/wm-spec/index.html#id2767771
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index 9e7ab85..12c4d55 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -5,6 +5,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include <assert.h>
 #include "nsWindow.h"
 
 #include "mozilla/ArrayUtils.h"
@@ -58,6 +59,10 @@
 #include <gtk/gtkprivate.h>
 #endif
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include "nsGkAtoms.h"
 
 #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
@@ -303,11 +308,14 @@ public:
 
     guint32 GetCurrentTime() const
     {
-        return gdk_x11_get_server_time(mWindow);
+        //return gdk_x11_get_server_time(mWindow);
+        return g_get_monotonic_time()/1000;
     }
 
     void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow)
     {
+        return;
+
         // Check for in-flight request
         if (!mAsyncUpdateStart.IsNull()) {
             return;
@@ -326,6 +334,8 @@ public:
     gboolean PropertyNotifyHandler(GtkWidget* aWidget,
                                    GdkEventProperty* aEvent)
     {
+        return FALSE;
+
         if (aEvent->atom !=
             gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
             return FALSE;
@@ -457,6 +467,10 @@ nsWindow::nsWindow()
     mXVisual  = nullptr;
     mXDepth   = 0;
 #endif /* MOZ_X11 */
+#ifdef GDK_WINDOWING_WAYLAND
+    mWaylandSurface = nullptr;
+#endif
+
     mPluginType          = PluginType_NONE;
 
     if (!gGlobalsInitialized) {
@@ -1384,6 +1398,9 @@ SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
 /* static */ guint32
 nsWindow::GetLastUserInputTime()
 {
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default()))
+        return sLastUserInputTime;
+
     // gdk_x11_display_get_user_time tracks button and key presses,
     // DESKTOP_STARTUP_ID used to start the app, drop events from external
     // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
@@ -1734,12 +1751,17 @@ nsWindow::GetNativeData(uint32_t aDataType)
         return (void*)mPluginNativeWindow->window;
 
     case NS_NATIVE_DISPLAY: {
-#ifdef MOZ_X11
         GdkDisplay* gdkDisplay = gdk_display_get_default();
+#if defined(MOZ_X11)
         if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
           return GDK_DISPLAY_XDISPLAY(gdkDisplay);
         }
-#endif /* MOZ_X11 */
+#endif
+#if defined(GDK_WINDOWING_WAYLAND)
+        if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
+          return gdk_wayland_display_get_wl_display(gdkDisplay);
+        }
+#endif
         return nullptr;
     }
     case NS_NATIVE_SHELLWIDGET:
@@ -1763,10 +1785,15 @@ nsWindow::GetNativeData(uint32_t aDataType)
     }
     case NS_NATIVE_OPENGL_CONTEXT:
       return nullptr;
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     case NS_NATIVE_COMPOSITOR_DISPLAY:
-        return gfxPlatformGtk::GetPlatform()->GetCompositorDisplay();
-#endif // MOZ_X11
+        if (mIsX11Display)
+          return gfxPlatformGtk::GetPlatform()->GetXCompositorDisplay();
+        else
+          return gfxPlatformGtk::GetPlatform()->GetWaylandCompositorDisplay();
+    case NS_NATIVE_COMPOSITOR_DISPLAY_X11:
+        return (void *)mIsX11Display;
+#endif
     default:
         NS_WARNING("nsWindow::GetNativeData called with bad value");
         return nullptr;
@@ -2133,6 +2160,12 @@ nsWindow::OnExposeEvent(cairo_t *cr)
     if (!listener)
         return FALSE;
 
+#ifdef GDK_WINDOWING_WAYLAND
+    // We don't have any Wayland surface to paint to
+    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
+        return FALSE;
+#endif
+
     LayoutDeviceIntRegion exposeRegion;
 #if (MOZ_WIDGET_GTK == 2)
     if (!ExtractExposeRegion(exposeRegion, aEvent)) {
@@ -3765,7 +3798,13 @@ nsWindow::Create(nsIWidget* aParent,
         // We can't draw directly to top-level window when client side
         // decorations are enabled. We use container with GdkWindow instead.
         GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+
+        // Always draw to mozcontainer on Wayland
         shellHasCSD = gtk_style_context_has_class(style, "csd");
+        // We use mContainer to draw on Wayland
+        if (!mIsX11Display) {
+            shellHasCSD = true;
+        }
 #endif
         if (!shellHasCSD) {
             // Use mShell's window for drawing and events.
@@ -3773,20 +3812,26 @@ nsWindow::Create(nsIWidget* aParent,
             // Prevent GtkWindow from painting a background to flicker.
             gtk_widget_set_app_paintable(mShell, TRUE);
         }
+
         // Set up event widget
         eventWidget = shellHasCSD ? container : mShell;
         gtk_widget_add_events(eventWidget, kEvents);
 
         gtk_container_add(GTK_CONTAINER(mShell), container);
         gtk_widget_realize(container);
-
+        
         // make sure this is the focus widget in the container
         gtk_widget_show(container);
         gtk_widget_grab_focus(container);
 
         // the drawing window
         mGdkWindow = gtk_widget_get_window(eventWidget);
-
+#if defined(GDK_WINDOWING_WAYLAND)
+        wl_surface *waylandSurface = moz_container_get_wl_surface(
+                                          MOZ_CONTAINER(container));
+        g_object_set_data(G_OBJECT(mGdkWindow), "WAYLAND_SURFACE",
+                          waylandSurface);
+#endif
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
             // windows, which are what gtk uses for popups.
@@ -3826,6 +3871,7 @@ nsWindow::Create(nsIWidget* aParent,
     case eWindowType_plugin_ipc_chrome:
     case eWindowType_plugin_ipc_content:
     case eWindowType_child: {
+        assert(0);
         if (parentMozContainer) {
             mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
             mHasMappedToplevel = parentnsWindow->mHasMappedToplevel;
@@ -4013,8 +4059,14 @@ nsWindow::Create(nsIWidget* aParent,
 
       mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    else {
+      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+      mSurfaceProvider.Initialize(mWaylandDisplay, mWaylandSurface);
+    }
+#endif
 #endif
-
     return NS_OK;
 }
 
@@ -4195,7 +4247,6 @@ nsWindow::NativeShow(bool aAction)
             if (mWindowType != eWindowType_invisible) {
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
-
             gtk_widget_show(mShell);
         }
         else if (mContainer) {
@@ -4697,14 +4748,10 @@ nsWindow::GrabPointer(guint32 aTime)
     if (!mGdkWindow)
         return;
 
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
     gint retval;
-    retval = gdk_pointer_grab(mGdkWindow, TRUE,
-                              (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
-                                             GDK_BUTTON_RELEASE_MASK |
-                                             GDK_ENTER_NOTIFY_MASK |
-                                             GDK_LEAVE_NOTIFY_MASK |
-                                             GDK_POINTER_MOTION_MASK),
-                              (GdkWindow *)nullptr, nullptr, aTime);
+    retval = gdk_seat_grab(gdkSeat, mGdkWindow, GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                           nullptr, nullptr, nullptr, nullptr);
 
     if (retval == GDK_GRAB_NOT_VIEWABLE) {
         LOG(("GrabPointer: window not viewable; will retry\n"));
@@ -4728,7 +4775,8 @@ nsWindow::ReleaseGrabs(void)
     LOG(("ReleaseGrabs\n"));
 
     mRetryPointerGrab = false;
-    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gdk_seat_ungrab(gdkSeat);
 }
 
 GtkWidget *
@@ -6675,8 +6723,7 @@ nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent,
             window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
         } else if (aHorizontal == 0) {
             window_edge = GDK_WINDOW_EDGE_NORTH;
-        } else {
-            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+        } else {            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
         }
     } else if (aVertical == 0) {
         if (aHorizontal < 0) {
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index b48fdad..c098f31 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -462,9 +462,12 @@ private:
     Window              mXWindow;
     Visual*             mXVisual;
     int                 mXDepth;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display*         mWaylandDisplay;
+    wl_surface*         mWaylandSurface;
+#endif
     mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 #endif
-
     // Upper bound on pending ConfigureNotify events to be dispatched to the
     // window. See bug 1225044.
     int mPendingConfigures;
diff --git a/widget/gtk/os-compatibility.c b/widget/gtk/os-compatibility.c
new file mode 100644
index 0000000..3439075
--- /dev/null
+++ b/widget/gtk/os-compatibility.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+* This file is a part of Weston project,
+* https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.c
+*/
+
+#include "mozilla-config.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/epoll.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "os-compatibility.h"
+
+int
+os_fd_set_cloexec(int fd)
+{
+	long flags;
+
+	if (fd == -1)
+		return -1;
+
+	flags = fcntl(fd, F_GETFD);
+	if (flags == -1)
+		return -1;
+
+	if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+		return -1;
+
+	return 0;
+}
+
+static int
+set_cloexec_or_close(int fd)
+{
+	if (os_fd_set_cloexec(fd) != 0) {
+		close(fd);
+		return -1;
+	}
+	return fd;
+}
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv)
+{
+	int ret;
+
+#ifdef SOCK_CLOEXEC
+	ret = socketpair(domain, type | SOCK_CLOEXEC, protocol, sv);
+	if (ret == 0 || errno != EINVAL)
+		return ret;
+#endif
+
+	ret = socketpair(domain, type, protocol, sv);
+	if (ret < 0)
+		return ret;
+
+	sv[0] = set_cloexec_or_close(sv[0]);
+	sv[1] = set_cloexec_or_close(sv[1]);
+
+	if (sv[0] != -1 && sv[1] != -1)
+		return 0;
+
+	close(sv[0]);
+	close(sv[1]);
+	return -1;
+}
+
+int
+os_epoll_create_cloexec(void)
+{
+	int fd;
+
+#ifdef EPOLL_CLOEXEC
+	fd = epoll_create1(EPOLL_CLOEXEC);
+	if (fd >= 0)
+		return fd;
+	if (errno != EINVAL)
+		return -1;
+#endif
+
+	fd = epoll_create(1);
+	return set_cloexec_or_close(fd);
+}
+
+static int
+create_tmpfile_cloexec(char *tmpname)
+{
+	int fd;
+
+#ifdef HAVE_MKOSTEMP
+	fd = mkostemp(tmpname, O_CLOEXEC);
+	if (fd >= 0)
+		unlink(tmpname);
+#else
+	fd = mkstemp(tmpname);
+	if (fd >= 0) {
+		fd = set_cloexec_or_close(fd);
+		unlink(tmpname);
+	}
+#endif
+
+	return fd;
+}
+
+/*
+ * Create a new, unique, anonymous file of the given size, and
+ * return the file descriptor for it. The file descriptor is set
+ * CLOEXEC. The file is immediately suitable for mmap()'ing
+ * the given size at offset zero.
+ *
+ * The file should not have a permanent backing store like a disk,
+ * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
+ *
+ * The file name is deleted from the file system.
+ *
+ * The file is suitable for buffer sharing between processes by
+ * transmitting the file descriptor over Unix sockets using the
+ * SCM_RIGHTS methods.
+ *
+ * If the C library implements posix_fallocate(), it is used to
+ * guarantee that disk space is available for the file at the
+ * given size. If disk space is insufficent, errno is set to ENOSPC.
+ * If posix_fallocate() is not supported, program may receive
+ * SIGBUS on accessing mmap()'ed file contents instead.
+ */
+int
+os_create_anonymous_file(off_t size)
+{
+	static const char template[] = "/weston-shared-XXXXXX";
+	const char *path;
+	char *name;
+	int fd;
+	int ret;
+
+	path = getenv("XDG_RUNTIME_DIR");
+	if (!path) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	name = malloc(strlen(path) + sizeof(template));
+	if (!name)
+		return -1;
+
+	strcpy(name, path);
+	strcat(name, template);
+
+	fd = create_tmpfile_cloexec(name);
+
+	free(name);
+
+	if (fd < 0)
+		return -1;
+
+#ifdef HAVE_POSIX_FALLOCATE
+	ret = posix_fallocate(fd, 0, size);
+	if (ret != 0) {
+		close(fd);
+		errno = ret;
+		return -1;
+	}
+#else
+	ret = ftruncate(fd, size);
+	if (ret < 0) {
+		close(fd);
+		return -1;
+	}
+#endif
+
+	return fd;
+}
diff --git a/widget/gtk/os-compatibility.h b/widget/gtk/os-compatibility.h
new file mode 100644
index 0000000..5dbd3b6
--- /dev/null
+++ b/widget/gtk/os-compatibility.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+ /*
+  * This file is a part of Weston project,
+  * https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.h
+  */
+
+#ifndef OS_COMPATIBILITY_H
+#define OS_COMPATIBILITY_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+int
+os_fd_set_cloexec(int fd);
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv);
+
+int
+os_epoll_create_cloexec(void);
+
+int
+os_create_anonymous_file(off_t size);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* OS_COMPATIBILITY_H */
diff --git a/widget/nsBaseWidget.cpp b/widget/nsBaseWidget.cpp
index 0b7d014..dc91cff 100644
--- a/widget/nsBaseWidget.cpp
+++ b/widget/nsBaseWidget.cpp
@@ -1406,7 +1406,8 @@ void nsBaseWidget::NotifyRemoteCompositorSessionLost(CompositorSession* aSession
 
 bool nsBaseWidget::ShouldUseOffMainThreadCompositing()
 {
-  return gfxPlatform::UsesOffMainThreadCompositing();
+  //return gfxPlatform::UsesOffMainThreadCompositing();
+  return false;
 }
 
 LayerManager* nsBaseWidget::GetLayerManager(PLayerTransactionChild* aShadowManager,
diff --git a/widget/nsIWidget.h b/widget/nsIWidget.h
index 2d14cc1..beea447 100644
--- a/widget/nsIWidget.h
+++ b/widget/nsIWidget.h
@@ -132,6 +132,8 @@ typedef void* nsNativeWidget;
 #define NS_NATIVE_PLUGIN_OBJECT_PTR    104
 #ifdef MOZ_X11
 #define NS_NATIVE_COMPOSITOR_DISPLAY   105
+// Return true the compositor display is X11
+#define NS_NATIVE_COMPOSITOR_DISPLAY_X11 106
 #endif // MOZ_X11
 #endif
 #ifdef MOZ_WIDGET_ANDROID
-- 
2.9.3

